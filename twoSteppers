#include <Servo.h>
#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include "utility/Adafruit_MS_PWMServoDriver.h"

Servo pen;
Adafruit_MotorShield AFMS = Adafruit_MotorShield(); 
Adafruit_StepperMotor *rotationMotor = AFMS.getStepper(200, 2); // Rotate
Adafruit_StepperMotor *elevationMotor = AFMS.getStepper(200, 1); // Elevate

double x_calibration = 0.5;
double y_calibration = 0.2;
int x_step = 1;
int y_step = 5;
int pen_down = 20;
int pen_up = 0;

void setup() {
  Serial.begin(9600);
  pen.attach(9);

  AFMS.begin();  // create with the default frequency 1.6KHz
  
  //rotationMotor->setSpeed(10);  // 10 rpm   
  //elevationMotor->setSpeed(10);  // 10 rpm   
}

void moveElevation() {
  for (int i = 0; i < 100; i++){}
}

//servo middle:55
void loop() {
  Serial.println("got here");
  /*movePenDown();
  delay(3000);
  movePenUp();
  delay(3000);*/

  // heart
  drawBezier(357, 746, 94, 543, 48, 358, 157, 358);
  delay(1000);
  drawBezier(157, 358, 265, 358, 354, 460, 354, 460);
  delay(1000);
  drawBezier(354, 461, 354, 460, 391, 372, 480, 369);
  delay(1000);
  drawBezier(480, 369, 568, 366, 494, 678, 357, 746);
  delay(3000);
}


void movePenDown() {
  pen.write(pen_down);
}

void movePenUp() {
  pen.write(pen_up);
}

// startx, starty, endx, endy
// use this but set "bool draw" to false if you just want to move between points but not draw
void drawLine(int startx, int starty, int endx, int endy, bool draw) {
 
  draw ? movePenDown() : movePenUp();
  
  if (startx == endx) {
    // vertical line
    if (endy > starty) {
      for (int y = starty; y < endy; y += y_calibration) {
        elevationMotor->step(y_step, FORWARD, MICROSTEP);
      }
    }
    else {
      for (int y = endy; y > starty; y -= y_calibration) {
        elevationMotor->step(y_step, BACKWARD, MICROSTEP);
      }
    }
  }

  else {
    double slope = (endy - starty) / (endx - startx);
    double intercept = -startx * slope + starty; 
    double last_x = 0.0;
    double last_y = 0.0;
    
    for (int t = 0; t < 1; t += 0.001) {
      double x = t;
      double y = slope * t + intercept;

      if ((x - last_x) > x_calibration) {
        Serial.println("moving x +");
        rotationMotor->step(1, FORWARD, MICROSTEP);
        last_x = x;
      }
      else if ((last_x - x) > x_calibration) {
        Serial.println("moving x -");
        rotationMotor->step(1, BACKWARD, MICROSTEP);
        last_x = x;
      }
      if ((y - last_y) > y_calibration) {
        Serial.println("moving   + y");
        elevationMotor->step(y_step, FORWARD, MICROSTEP);
        last_y = y;
      }
      else if ((last_y - y) > y_calibration) {
        Serial.println("moving   - y");
        elevationMotor->step(y_step, BACKWARD, MICROSTEP);
        last_y = y;
      }
    }
  }
}


void drawRect(int cx, int cy, int width, int height) {
  drawLine(cx, cy, cx + width, cy, true);
  drawLine(cx + width, cy, cx + width, cy + height, true);
  drawLine(cx + width, cy + height, cx, cy + height, true);
  drawLine(cx, cy + height, cx, cy, true);
}

void drawBezier(int p0x, int p0y, int p1x, int p1y, int p2x, int p2y, int p3x, int p3y) {
  double last_x = 0.0;
  double last_y = 0.0;
  for (double t = 0; t < 1.0; t += 0.001) {
    double x = pow((1-t),3)*p0x + 3*t*pow((1-t), 2)*p1x + 3*pow(t,2)*(1-t)*p2x + pow(t,3) * p3x;
    double y = pow((1-t),3)*p0y + 3*t*pow((1-t), 2)*p1y + 3*pow(t,2)*(1-t)*p2y + pow(t,3) * p3y;
    if ((x - last_x) > x_calibration) {
      Serial.println("moving x +");
      rotationMotor->step(1, FORWARD, MICROSTEP);
      last_x = x;
    }
    else if ((last_x - x) > x_calibration) {
      Serial.println("moving x -");
      rotationMotor->step(1, BACKWARD, MICROSTEP);
      last_x = x;
    }
    if ((y - last_y) > y_calibration) {
      Serial.println("moving   + y");
      elevationMotor->step(y_step, FORWARD, MICROSTEP);
      last_y = y;
    }
    else if ((last_y - y) > y_calibration) {
      Serial.println("moving   - y");
      elevationMotor->step(y_step, BACKWARD, MICROSTEP);
      last_y = y;
    }
  }
}

/*void drawEllipse(int cx, int cy, int rx, int ry) {
  // this is going to try parametric graphing

  double prevx = rx * cos(0) + cx;
  double prevy = ry * sin(0) + cy;
  for (int i = 0; i < 360; i++) {
    double t = i / 180 * 3.14159;
    int x = (int) (rx * cos(t) + cx);
    int y = (int) (ry * sin(t) + cy); 
    double dx = (prevx - x);
    double dy = (prevy - y);
    double factor = 1 / dx;
    dy = dy * factor;
  }
}*/
/*

void drawPolyLine(int xs[], int ys[]) {
    moveTo(xs[0], ys[0], false);
    for (int i = 0; i < sizeof(xs); i += 2) {
      drawLine(xs[i], ys[i], true);
    }
}
*/
/*


int transform(int x, int y) {
  // this function will apply a Galls-Peter transformation
  return 0;
}*/
